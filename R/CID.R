#' Main function for generating an ensemble of machine learning models.
#'
#' @param R Reference dataset; user should do data("training_HPCA") and then set R to training_HPCA
#' @param model.use Machine learning model to use. Default option is neural network. Can also be set to 'svm' or 'rf'.
#' @param N Number of machine learning models to train (for nn and svm). Default is 100.
#' @param num.cores Number of cores to use. Default is 1.
#' @param verbose if TRUE, code will report outputs. Default is TRUE.
#' @param hidden Number of hidden layers in the neural network. Default is 1.
#' @param set.seed If true, seed is set to ensure reproducibility of these results. Default is TRUE.
#' @param seed if set.seed is TRUE, seed is set to 42.
#' @seealso [SignacFast()] for a function that uses the models generated by [ModelGenerator()]
#' @return models for predicting cell types based on reference dataset
#' @export
#' @examples
#' \dontrun{
#' # load bootstrapped training data
#' data("training_HPCA")
#' 
#' # Generate ensemble of 100 neural networks
#' Models = ModelGenerator(R = training_HPCA, num.cores = 4)
#' 
#' # save results
#' save(Models, file = "models.rda")
#' }
ModelGenerator <- function(R, model.use = "nn", N = 100, num.cores = 1, verbose = T, hidden = 1, set.seed = T, seed = '42')
{
  if (verbose)
  {
    cat(" ..........  Entry in ModelGenerator \n");
    ta = proc.time()[3];
    
    # main function
    cat(" ..........  Running ModelGenerator on input reference dataset :\n");
    cat("             classifiers = ", length(R$Reference), "\n", sep = "");
    cat("             total classifier stack = ", N * length(R$Reference), "\n", sep = "");
  }
  
  res = lapply(R$Reference, function(x){
    # train a neural network (N times)
    if (model.use == "nn"){
      if (set.seed)
      {
        RNGkind("L'Ecuyer-CMRG")
        set.seed(seed = seed)
      }
      out = suppressWarnings(parallel::mclapply(1:N, function(y) {
        model.fit = neuralnet::neuralnet(celltypes~.,hidden=hidden,data=x, act.fct = 'logistic', linear.output = F)
        model.fit$generalized.weights <- NULL
        model.fit$covariate <- NULL
        model.fit$data <- NULL
        model.fit$response <- NULL
        model.fit$startweights <- NULL
        model.fit$call <- NULL
        model.fit$net.result <- NULL
        model.fit$exclude <- NULL
        model.fit$err.fct <- NULL
        model.fit$result.matrix <- NULL
        return(model.fit)
      }, mc.cores = num.cores))
      }
    # if desired, run svm
    if (model.use == "svm") {
      out = e1071::svm(celltypes ~ ., data = x, probability=TRUE)
    }
    # if desired, run RF
    if (model.use == "rf") {
      out = parallel::mclapply(1:N, function(y) {
        randomForest::randomForest(celltypes ~ ., data=x, keep.forest = TRUE)
      }, mc.cores = num.cores)
    }
    outs = list(
      genes = colnames(x)[-ncol(x)],
      classifiers = out
    )
    return(outs)
  })
  
  if (verbose) {
    tb = proc.time()[3] - ta;
    cat("\n ..........  Exit ModelGenerator.\n");
    cat("             Execution time = ", tb, " s.\n", sep = "");
  }
  return(res)
}

#' Main function for fast classification of Signac with precomputed models
#'
#' @param E a sparse gene (rows) by cell (column) matrix, or a Seurat object. Rows are HUGO symbols.
#' @param Models as returned by data("Models_HPCA"). An ensemble of 1,800 neural network models.
#' @param spring.dir If using SPRING, directory to categorical_coloring_data.json. Default is NULL.
#' @param model.use Machine learning model to use. Default option is neural network. Can also be set to 'svm' or 'rf'.
#' @param threshold Probability threshold for assigning cells to "Unclassified." Default is 0.
#' @param smooth if TRUE, smooths the cell type classifications. Default is TRUE.
#' @param impute if TRUE, gene expression values are imputed prior to cell type classification. Default is TRUE.
#' @param verbose if TRUE, code will report outputs. Default is TRUE.
#' @param do.normalize if TRUE, cells are normalized to the mean library size. Default is TRUE.
#' @param num.cores number of cores to use for parallel computation. Default is 1. 
#' @param return.probability if TRUE, returns the probability associated with each cell type label. Default is TRUE.
#' @seealso [Signac()] for another classification function, [GenerateModels()] for building stack of neural networks
#' @return cell type annotations at every level of the hierarchy
#' @export
#' @examples
#' \dontrun{
#' # download bootstrapped reference data for training models; or load models previously generated with GenerateModels
#' data("training_HPCA")
#' # train models (default is neural networks)
#' Models = ModelGenerator(R = training_HPCA, N = 100, num.cores = 4)
#' 
#' # download single cell data for classification
#' download.file("https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/pbmc_1k_v3_filtered_feature_bc_matrix.h5", destfile = "pbmc_1k_v3_filtered_feature_bc_matrix.h5")
#' 
#' # load data, process with Seurat
#' library(Seurat)
#' E = Read10X_h5(filename = "pbmc_1k_v3_filtered_feature_bc_matrix.h5")
#' pbmc <- CreateSeuratObject(counts = E, project = "pbmc")
#' 
#' # run Seurat pipeline
#' pbmc <- SCTransform(pbmc, verbose = FALSE)
#' pbmc <- RunPCA(pbmc, verbose = FALSE)
#' pbmc <- RunUMAP(pbmc, dims = 1:30, verbose = FALSE)
#' pbmc <- FindNeighbors(pbmc, dims = 1:30, verbose = FALSE)
#' 
#' # classify cells
#' labels = SignacFast(E = pbmc, Models = Models)
#' celltypes = Generate_lbls(labels, E = pbmc)
#' }
SignacFast <- function(E, Models, spring.dir = NULL, num.cores = 1, model.use = "nn", threshold = 0, smooth = T, impute = T, verbose = T, do.normalize = T, return.probability = F)
{
  flag = class(E) == "Seurat"
  
  if (flag){
    default.assay <- Seurat::DefaultAssay(E)
    edges = E@graphs[[which(grepl(paste0(default.assay, "_nn"), names(E@graphs)))]]
  }
  
  if (verbose)
  {
    cat(" ..........  Entry in SignacFast \n");
    ta = proc.time()[3];
    
    # main function
    if (!flag)
    {
      cat(" ..........  Running SignacFast on input data matrix :\n");
    } else {
      cat(" ..........  Running SignacFast on Seurat object :\n");
    }
    cat("             nrow = ", nrow(E), "\n", sep = "");
    cat("             ncol = ", ncol(E), "\n", sep = "");
  }
  
  # keep only unique row names
  logik = CID.IsUnique(rownames(E))
  E = E[logik,]
  
  # intersect genes with reference set
  gns = sort(unique(unlist(sapply(Models, function(x){ x$genes }))))
  V = E[rownames(E) %in% gns, ]
  
  if (class(V) %in% "data.frame")
    V = Matrix::Matrix(as.matrix(V), sparse = T)
  
  # normalize to the mean library size
  if (do.normalize)
  {
    if (!flag)
    {
      V = CID.Normalize(V)
    } else {
      V = CID.Normalize(V@assays[[default.assay]]@counts)
    }
  }
  
  # normalization function for gene expression scaling
  normalize <- function(x) {
    return ((x - min(x)) / (max(x) - min(x)))
  }
  
  # normalize V
  V = t(apply(V, 1, function(x){
    normalize(x)
  }))
  logik = apply(V, 1, function(x) {any(is.na(x))})
  V = V[!logik,]
  
  # set up imputation matrices
  if (flag) {
    dM = CID.GetDistMat(edges)
    louvain = CID.Louvain(edges = edges)
  } else {
    edges = CID.LoadEdges(data.dir = spring.dir)
    dM = CID.GetDistMat(edges)
    louvain = CID.Louvain(edges = edges)
  }
  res = pbmcapply::pbmclapply(Models, FUN = function(x){
    
    Z = V[rownames(V) %in% x$genes,]
    
    # run imputation (if desired)
    if (impute){
      Z = KSoftImpute(E = Z, dM = dM, verbose = F)
      Z = t(apply(Z, 1, function(x){
        normalize(x)
      }))
    }
    
    # zero impute in any missing genes
    dummy = Matrix::Matrix(0, nrow = length(x$genes) - nrow(Z), ncol = ncol(Z))
    rownames(dummy) <- x$genes[!x$genes %in% rownames(Z)]
    Z = rbind(Z, dummy)
    Z = Z[order(rownames(Z)),]
    
    # generate predictions
    if (model.use == "nn"){
      res = lapply(x$classifiers, function(y) {
        Predict = stats::predict(y, Matrix::t(Z))
        colnames(Predict) <- sort(y$model.list$response)
        return(Predict)
      })
      res = res[sapply(res, function(x) !is.null(x))]
      res.squared.mean <- Reduce("+", lapply(res, "^", 2)) / length(res)
      res = Reduce(res, f = '+') / length(res)
      res.variance <- res.squared.mean - res^2
      res.sd <- sqrt(res.variance)
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      errors = round(sapply(1:length(xx), function(x){res.sd[x, xx[x]]}), digits = 4)
      df = data.frame(celltypes = celltypes, probability = round(kmax, digits = 3), sd = errors, percent_features_detected = round(Matrix::colSums(Z != 0) / nrow(Z), digits = 3) * 100)
    }
    # if desired, run svm
    if (model.use == "svm") {
      xx = stats::predict(x$classifiers, t(Z), probability=TRUE)
      res = attr(xx, "probabilities")
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      df = data.frame(celltypes = celltypes, probability = kmax)
      df$celltypes = as.character(df$celltypes)
    }
    # if desired, run RF
    if (model.use == "rf") {
      res = lapply(x$classifiers, function(y) {
        stats::predict(y,newdata=Matrix::t(Z),type="prob")
      })
      res = res[sapply(res, function(x) !is.null(x))]
      res = Reduce(res, f = '+') / length(res)
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      df = data.frame(celltypes = celltypes, probability = kmax)
      df$celltypes = as.character(df$celltypes)
    }
    # smooth the output classifications
    if (smooth & any(as.character(unique(x$celltypes)) %in% c("T","B","Immune", "Myeloid", "NonImmune", "Lymphocytes", "Monocytes.Neutrophils", "Monocytes", "Fibroblasts", "Epithelial", "Endothelial", "Macrophages", "MPh")))
      df$celltypes = CID.smooth(df$celltypes, dM[[1]])
    
    # return probabilities and cell type classifications
    if (return.probability){
      return(df)
    } else {
      return(df$celltypes)
    }
  }, mc.cores = num.cores)
  
  res$louvain = louvain
  
  if (verbose) {
    tb = proc.time()[3] - ta;
    cat("\n ..........  Exit SignacFast.\n");
    cat("             Execution time = ", tb, " s.\n", sep = "");
  }
  return(res)
}


#' Main function for solo-decision classification
#'
#' @param E a sparse gene (rows) by cell (column) matrix, or a Seurat object. Rows are HUGO symbols.
#' @param R Reference dataset; user should do data("Reference_sim") and then set R to Refernence_sim.
#' @param spring.dir If using SPRING, directory to categorical_coloring_data.json. Default is NULL.
#' @param model.use Machine learning model to use. Default option is neural network. Can also be set to 'svm' or 'rf'.
#' @param N Number of machine learning models to train (for nn and svm). Default is 25.
#' @param num.cores Number of cores to use. Default is 1.
#' @param threshold Probability threshold for assigning cells to "Unclassified." Default is 0.5.
#' @param smooth if TRUE, smooths the cell type classifications. Default is TRUE.
#' @param impute if TRUE, gene expression values are imputed prior to cell type classification. Default is TRUE.
#' @param verbose if TRUE, code will report outputs. Default is TRUE.
#' @param do.normalize if TRUE, cells are normalized to the mean library size. Default is TRUE.
#' @param probability if TRUE, returns the probability associated with each cell type label. Default is TRUE.
#' @param hidden Number of hidden layers in the neural network. Default is 1.
#' @return annotations
#' @export
Signac_Solo <- function(E, R , spring.dir = NULL, model.use = "nn", N = 100, num.cores = 1, threshold = 0.5, smooth = T, impute = T, verbose = T, do.normalize = T, probability = F, hidden = 1)
{
  
  flag = class(E) == "Seurat"
  
  if (flag & impute)
    edges = E@graphs$RNA_nn
  
  if (verbose)
  {
    cat(" ..........  Entry in Signac_Solo \n");
    ta = proc.time()[3];
    
    # main function
    if (!flag)
    {
      cat(" ..........  Running Signac_Solo on input data matrix :\n");
    } else {
      cat(" ..........  Running Signac_Solo on Seurat object :\n");
    }
    cat("             nrow = ", nrow(E), "\n", sep = "");
    cat("             ncol = ", ncol(E), "\n", sep = "");
  }
  
  # keep only unique row names
  logik = CID.IsUnique(rownames(E))
  E = E[logik,]
  
  # intersect genes with reference set
  gns = intersect(rownames(E), colnames(R))
  V = E[rownames(E) %in% gns, ]
  
  # make sure data are in the same order
  V = V[order(rownames(V)),]
  
  if (class(V) %in% "data.frame")
    V = Matrix::Matrix(as.matrix(V), sparse = T)
  
  # normalize to the mean library size
  if (do.normalize)
  {
    if (!flag)
    {
      V = CID.Normalize(V)
    } else {
      V = CID.Normalize(V@assays$RNA@counts)
    }
  }
  
  # normalization function for gene expression scaling
  normalize <- function(x) {
    return ((x - min(x)) / (max(x) - min(x)))
  }
  # normalize V
  V = t(apply(V, 1, function(x){
    normalize(x)
  }))
  logik = apply(V, 1, function(x) {any(is.na(x))})
  V = V[!logik,]
  
  # set up imputation matrices
  if (flag) {
    dM = CID.GetDistMat(edges)
    louvain = CID.Louvain(edges = edges)
  } else {
    edges = CID.LoadEdges(data.dir = spring.dir)
    dM = CID.GetDistMat(edges)
    louvain = CID.Louvain(edges = edges)
  }
  
    # keep same gene names
    gns = sort(intersect(rownames(V), colnames(R)))
    Z = V[rownames(V) %in% gns, ]
    dat = R[,colnames(R) %in% gns]
    Z = Z[order(rownames(Z)), ]
    dat = dat[, order(colnames(dat))]
    
    # remove any low variance genes
    kmu = apply(Z, 1, function(x){sum(x != 0)})
    logik = kmu > 0;
    Z = Z[logik,]
    dat = dat[,logik]
    
    # run imputation (if desired)
    if (impute){
      Z = KSoftImpute(E = Z, dM = dM, verbose = F)
      Z = t(apply(Z, 1, function(x){
        normalize(x)
      }))
    }
    
    # build training set
    df = data.frame(dat, celltypes = R$celltypes)
    
    # train a neural network (N times)
    if (model.use == "nn"){
      res = suppressWarnings(parallel::mclapply(1:N, function(x) {
        nn=neuralnet::neuralnet(celltypes~.,hidden=hidden,data=df, act.fct = 'logistic', linear.output = F)
        Predict = stats::predict(nn, Matrix::t(Z))
        colnames(Predict) <- sort(nn$model.list$response)
        return(Predict)
      }, mc.cores = num.cores))
      
      # compute standard deviation of predictions
      err = do.call(cbind, lapply(res, function(x) {x[,1]}))
      res.sd <- apply(err, 1, sd)
      err = do.call(cbind, lapply(res, function(x) {x[,2]}))
      res.sd <- cbind(res.sd, apply(err, 1, sd))
      
      ## compute average probability
      res = Reduce(res, f = '+') / N
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      df = data.frame(celltypes = celltypes, probability = kmax, error = res.sd[xx], percent_features_detected = round(Matrix::colSums(Z != 0) / nrow(Z), digits = 3) * 100, genes_detected = round(Matrix::colSums(E != 0), digits = 3) * 100)
      df$celltypes = as.character(df$celltypes)
    }
    # if desired, run svm
    if (model.use == "svm") {
      model = e1071::svm(celltypes ~ ., data = df, probability=TRUE)
      xx = stats::predict(model, t(Z), probability=TRUE)
      res = attr(xx, "probabilities")
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      df = data.frame(celltypes = celltypes, probability = kmax)
      df$celltypes = as.character(df$celltypes)
    }
    # if desired, run RF
    if (model.use == "rf") {
      res = parallel::mclapply(1:N, function(x) {
        model = randomForest::randomForest(celltypes ~ ., data=df, keep.forest = TRUE)
        stats::predict(model,newdata=Matrix::t(Z),type="prob")
      }, mc.cores = num.cores)
      res = Reduce(res, f = '+') / N
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      df = data.frame(celltypes = celltypes, probability = kmax)
      df$celltypes = as.character(df$celltypes)
    }
    # smooth the output classifications
    if (smooth)
      df$celltypes = CID.smooth(df$celltypes, dM[[1]])

  
  if (verbose) {
    tb = proc.time()[3] - ta;
    cat("\n ..........  Exit Signac_Solo. \n");
    cat("             Execution time = ", tb, " s.\n", sep = "");
  }
    
    # return probabilities and cell type classifications
    if (probability){
      return(df)
    } else {
      return(df$celltypes)
    }
    
}
#' Main function for classification
#'
#' @param E a sparse gene (rows) by cell (column) matrix, or a Seurat object. Rows are HUGO symbols.
#' @param R Reference dataset; user should do data("Reference_sim") and then set R to Refernence_sim.
#' @param spring.dir If using SPRING, directory to categorical_coloring_data.json. Default is NULL.
#' @param model.use Machine learning model to use. Default option is neural network. Can also be set to 'svm' or 'rf'.
#' @param N Number of machine learning models to train (for nn and svm). Default is 100.
#' @param num.cores Number of cores to use. Default is 1.
#' @param threshold Probability threshold for assigning cells to "Unclassified." Default is 0.
#' @param smooth if TRUE, smooths the cell type classifications. Default is TRUE.
#' @param impute if TRUE, gene expression values are imputed prior to cell type classification. Default is TRUE.
#' @param verbose if TRUE, code will report outputs. Default is TRUE.
#' @param do.normalize if TRUE, cells are normalized to the mean library size. Default is TRUE.
#' @param return.probability if TRUE, returns the probability associated with each cell type label. Default is TRUE.
#' @param hidden Number of hidden layers in the neural network. Default is 1.
#' @param set.seed If true, seed is set to ensure reproducibility of these results. Default is TRUE.
#' @param seed if set.seed is TRUE, seed is set to 42.
#' @return cell type annotations
#' @export
Signac <- function(E, R , spring.dir = NULL, model.use = "nn", N = 100, num.cores = 1, threshold = 0, smooth = T, impute = T, verbose = T, do.normalize = T, return.probability = F, hidden = 1, set.seed = T, seed = '42')
{
  flag = class(E) == "Seurat"
  
  if (flag){
    default.assay <- Seurat::DefaultAssay(E)
    edges = E@graphs[[which(grepl(paste0(default.assay, "_nn"), names(E@graphs)))]]
  }
  
  if (verbose)
  {
    cat(" ..........  Entry in Signac \n");
    ta = proc.time()[3];
    
    # main function
    if (!flag)
    {
      cat(" ..........  Running Signac on input data matrix :\n");
    } else {
      cat(" ..........  Running Signac on Seurat object :\n");
    }
    cat("             nrow = ", nrow(E), "\n", sep = "");
    cat("             ncol = ", ncol(E), "\n", sep = "");
  }
  
  # keep only unique row names
  logik = CID.IsUnique(rownames(E))
  E = E[logik,]
  
  # intersect genes with reference set
  gns = intersect(rownames(E), R$genes)
  V = E[rownames(E) %in% gns, ]
  
  if (class(V) %in% "data.frame")
    V = Matrix::Matrix(as.matrix(V), sparse = T)
  
  # normalize to the mean library size
  if (do.normalize)
  {
    if (!flag)
    {
      V = CID.Normalize(V)
    } else {
      V = CID.Normalize(V@assays[[default.assay]]@counts)
    }
  }

  # normalization function for gene expression scaling
  normalize <- function(x) {
    return ((x - min(x)) / (max(x) - min(x)))
  }
  
  # normalize V
  V = t(apply(V, 1, function(x){
    normalize(x)
  }))
  logik = apply(V, 1, function(x) {any(is.na(x))})
  V = V[!logik,]
  
  # set up imputation matrices
      if (flag) {
        dM = CID.GetDistMat(edges)
        louvain = CID.Louvain(edges = edges)
      } else {
      edges = CID.LoadEdges(data.dir = spring.dir)
      dM = CID.GetDistMat(edges)
      louvain = CID.Louvain(edges = edges)
      }
  res = pbmcapply::pbmclapply(R$Reference, FUN = function(x){
    # keep same gene names
    gns = sort(intersect(rownames(V), colnames(x)))
    Z = V[rownames(V) %in% gns, ]
    dat = x[,colnames(x) %in% gns]
    Z = Z[order(rownames(Z)), ]
    dat = dat[, order(colnames(dat))]
    
    # remove any low variance genes
    kmu = apply(Z, 1, function(x){sum(x != 0)})
    logik = kmu > 0;
    Z = Z[logik,]
    dat = dat[,logik]
    
    # run imputation (if desired)
    if (impute){
      Z = KSoftImpute(E = Z, dM = dM, verbose = F)
      Z = t(apply(Z, 1, function(x){
        normalize(x)
      }))
    }
    
    # build training set
    df = data.frame(dat, celltypes = x$celltypes)
    
    # train a neural network (N times)
    if (model.use == "nn"){
      if (set.seed)
      {
        RNGkind("L'Ecuyer-CMRG")
        set.seed(seed = seed)
      }
      res = suppressWarnings(lapply(1:N, function(x) {
        nn=neuralnet::neuralnet(celltypes~.,hidden=hidden,data=df, act.fct = 'logistic', linear.output = F)
        Predict = stats::predict(nn, Matrix::t(Z))
        colnames(Predict) <- sort(nn$model.list$response)
        return(Predict)
      }))
      res = res[sapply(res, function(x) !is.null(x))]
      res.squared.mean <- Reduce("+", lapply(res, "^", 2)) / length(res)
      res = Reduce(res, f = '+') / length(res)
      res.variance <- res.squared.mean - res^2
      res.sd <- sqrt(res.variance)
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      errors = round(sapply(1:length(xx), function(x){res.sd[x, xx[x]]}), digits = 4)
      df = data.frame(celltypes = celltypes, probability = round(kmax, digits = 3), sd = errors, percent_features_detected = round(Matrix::colSums(Z != 0) / nrow(Z), digits = 3) * 100)
    }
    # if desired, run svm
    if (model.use == "svm") {
      model = e1071::svm(celltypes ~ ., data = df, probability=TRUE)
      xx = stats::predict(model, t(Z), probability=TRUE)
      res = attr(xx, "probabilities")
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      df = data.frame(celltypes = celltypes, probability = kmax)
      df$celltypes = as.character(df$celltypes)
    }
    # if desired, run RF
    if (model.use == "rf") {
      res = lapply(1:N, function(x) {
        model = randomForest::randomForest(celltypes ~ ., data=df, keep.forest = TRUE)
        stats::predict(model,newdata=Matrix::t(Z),type="prob")
      })
      res = Reduce(res, f = '+') / N
      xx = apply(res, 1, which.max)
      celltypes = colnames(res)[xx]
      kmax = apply(res, 1, max)
      celltypes[kmax < threshold] = "Unclassified"
      df = data.frame(celltypes = celltypes, probability = kmax)
      df$celltypes = as.character(df$celltypes)
    }
      # smooth the output classifications
    if (smooth & any(as.character(unique(x$celltypes)) %in% c("T","B","Immune", "Myeloid", "NonImmune", "Lymphocytes", "Monocytes.Neutrophils", "Monocytes", "Fibroblasts", "Epithelial", "Endothelial", "Macrophages", "MPh")))
        df$celltypes = CID.smooth(df$celltypes, dM[[1]])
    
    # return probabilities and cell type classifications
    if (return.probability){
      return(df)
    } else {
      return(df$celltypes)
    }
    }, mc.cores = num.cores)
  
  res$louvain = louvain
  
  if (verbose) {
    tb = proc.time()[3] - ta;
    cat("\n ..........  Exit Signac.\n");
    cat("             Execution time = ", tb, " s.\n", sep = "");
  }
    return(res)
}

#' Generate labels from classifications
#'
#' @param cr list returned by Signac function call.
#' @param E a sparse gene (rows) by cell (column) matrix, or a Seurat object. Rows are HUGO symbols.
#' @param spring.dir If using SPRING, directory to categorical_coloring_data.json. Default is NULL.
#' @param smooth if TRUE, smooths the cell type classifications. Default is TRUE.
#' @param new_populations Character vector specifying any new cell types that were learned by Signac. Default is NULL.
#' @param new_categories If new_populations are set to a cell type, new_category is a corresponding character vector indicating the population that the new population belongs to. Default is NULL.
#' @param min.cells If desired, any cell population with equal to or less than N cells is set to "Unclassified." Default is 10 cells.
#' @return cell type labels (list) for each level of the hierarchy.
#' @export
Generate_lbls = function(cr, spring.dir = NULL, E = NULL, smooth = T, new_populations = NULL, new_categories = NULL, min.cells = 10)
{
  
  if (!is.null(spring.dir)){
    edges = CID.LoadEdges(data.dir = spring.dir)
    dM = CID.GetDistMat(edges)
  }
  
  flag = class(E) == "Seurat"
  if (flag) {
    default.assay <- Seurat::DefaultAssay(E)
    edges = E@graphs[[which(grepl(paste0(default.assay, "_nn"), names(E@graphs)))]]
    dM = CID.GetDistMat(edges)
  }
  
  res = list("")
  louvain = cr$louvain
  cr = cr[-which(names(cr) == "louvain")]
  if ("probability" %in% names(cr[[1]])){
    cr = lapply(cr, function(x) {x$celltypes})
  }
  
  cr = lapply(cr, function(x) {as.character(x)})
  
  for (j in 1:length(cr))
  {
    if (names(cr)[j] == "All"){
      res[[j]] = cr[[j]]
    } else {
      qq = res[[j - 1]]
      logik = qq == names(cr)[j]
      qq[logik] = cr[[j]][logik]
      res[[j]] = qq
    }
  }
  
  cellstates = res[[length(res)]]
  celltypes = cellstates
  celltypes[celltypes %in% c("B.memory", "B.naive")] = "B"
  celltypes[celltypes %in% c("DC", "Mon.Classical", "Mon.NonClassical", "Neutrophils", "Monocytes", "Macrophages")] = "MPh"
  celltypes[celltypes %in% c("NK", "T.CD4.naive", "T.CD4.memory", "T.CD8", "T.regs", "T.CD8.naive", "T.CD8.memory", "T.CD8.cm","T.CD8.em" , "T.cyto")] = "TNK"
  celltypes[celltypes %in% c("Endothelial", "Fibroblasts", "HSC", "Epithelial")] = "NonImmune"
  immune = res[[1]]  

  if (!is.null(new_populations))
  {
    for (j in 1:length(new_populations))
      celltypes[celltypes %in% new_populations[j]] = new_categories[j]
  }
  
  # assign Unclassifieds
  if (!is.null(spring.dir) | flag){
  celltypes = CID.entropy(celltypes, dM)
  immune = CID.entropy(immune, dM)
  # smooth 
  if (smooth) {
    celltypes= CID.smooth(celltypes, dM[[1]])
    #cellstates = CID.smooth(cellstates, dM[[1]])
    immune = CID.smooth(immune, dM[[1]])
  }
  }
  logik = immune == "Unclassified" | celltypes == "Unclassified" | cellstates == "Unclassified"
  cellstates[logik] = "Unclassified"
  celltypes[logik] = "Unclassified"
  immune[logik] = "Unclassified"
  
  res$Immune = immune
  if (!is.null(spring.dir) | flag)
  {
  do = data.frame(table(louvain[cellstates == "Unclassified"]))
  df = data.frame(table(louvain[louvain %in% do$Var1]))
  logik = (1 - phyper(do$Freq, df$Freq , length(cellstates) - do$Freq, sum(cellstates == "Unclassified"))) < 0.01;
  if (any(logik)){
    do = do[logik,]
    logik = do$Freq > 3; # require at least 3 cell communities
    if (any(logik)){
      celltypes_novel  = celltypes;
      cellstates_novel = cellstates;
      cat("             Signac found", sum(logik), "novel celltypes!\n");
      lbls = rep("All", ncol(E))
      logik = louvain %in% do$Var1[logik] & cellstates == "Unclassified";
      lbls[logik] = louvain[logik]
      if (!flag) {
        colnames(E) <- lbls
        new_lbls = CID.PosMarkers2(E, cellstates)
        cellstates_novel = new_lbls$lbls
        celltypes_novel[grepl("^[+]", cellstates_novel)] = new_lbls$lbls[grepl("^[+]", cellstates_novel)]
        res$CellTypes_novel = celltypes_novel
        res$CellStates_novel = cellstates_novel
      } else {
        cellstates_novel[lbls != "All"] = paste0("+ Novel cluster", lbls[lbls != "All"])
        celltypes_novel[lbls != "All"] = paste0("+ Novel cluster", lbls[lbls != "All"])
        res$CellTypes_novel = celltypes_novel
        res$CellStates_novel = cellstates_novel
      }
    } 
  }
  }

  df = data.frame(table(celltypes))
  logik = df$Freq < (min.cells + 1)
  if (any(logik))
    celltypes[celltypes %in% as.character(df[,1][logik])] <- "Unclassified"
  
  df = data.frame(table(cellstates))
  logik = df$Freq < (min.cells + 1)
  if (any(logik))
    cellstates[cellstates %in% as.character(df[,1][logik])] <- "Unclassified"
  
  res$CellTypes = celltypes
  res$CellStates = cellstates

  names(res)[names(res) == ""] = paste0("L", 1:sum(names(res) == ""))
  
  res$clusters = louvain

  return(res)
}

#' Main function for learning
#'
#' @param E a sparse gene (rows) by cell (column) matrix. Rows are HUGO symbols.
#' @param learned_types Types for learning
#' @param labels cell type labels for the columns of E.
#' @param size Number of bootstrapped samples for machine learning. Default is 1,000.
#' @param logfc.threshold Cutoff for feature selection. Default is 0.25.
#' @param p.val.adj Cutoff for feature selection. Default is 0.05.
#' @param spring.dir if using SPRING, directory to categorical_coloring_data.json. Default is NULL.
#' @param impute if TRUE, performs imputation prior to bootstrapping. Default is TRUE.
#' @param verbose if TRUE, code speaks. Default is TRUE.
#' @return training data frame to be added to a new reference training set
#' @export
SignacLearn <- function (E, learned_types, labels, size = 1000, impute = T, spring.dir = NULL, logfc.threshold = 0.25, p.val.adj = 0.05, verbose = T)
{
  if (verbose)
  {
    cat(" ..........  Entry in SignacLearn \n");
    ta = proc.time()[3];
    
    # main function
    cat(" ..........  Running SignacLearn on input data matrix :\n");
    cat("             nrow = ", nrow(E), "\n", sep = "");
    cat("             ncol = ", ncol(E), "\n", sep = "");
  }
  
  # set up imputation matrices
  if (impute){
    edges = CID.LoadEdges(data.dir = spring.dir)
    dM = CID.GetDistMat(edges)
    louvain = CID.Louvain(edges = edges)
  }
  
  # keep only unique row names
  logik = CID.IsUnique(rownames(E))
  E = E[logik,]
  colnames(E) <- 1:ncol(E)

  # run feature selection  
  ctrl <- Seurat::CreateSeuratObject(counts = E[,labels %in% learned_types], project = "Signac", min.cells = 0)
  ctrl <- Seurat::NormalizeData(ctrl)
  ctrl <- Seurat::AddMetaData(ctrl, metadata=labels[labels %in% learned_types], col.name = "celltypes")
  ctrl <- Seurat::SetIdent(ctrl, value='celltypes')
  mrks = Seurat::FindMarkers(ctrl, ident.1 = learned_types[1], ident.2 = learned_types[2], only.pos = F, logfc.threshold = logfc.threshold)
  mrks = mrks[mrks$p_val_adj < p.val.adj,]
  # bootstrap data
  dat = E[rownames(E) %in% rownames(mrks),]
  mrks$cluster = learned_types[1]
  mrks$cluster[mrks$avg_logFC < 0] = learned_types[2]
  mrks$gene = rownames(mrks)
  
  xx = labels
  
  # run imputation (if desired)
  if (impute)
    Z = KSoftImpute(E = dat, dM = dM, verbose = F)
  
  cts = split.data.frame(mrks, f = mrks$cluster)
  N = lapply(cts, function(x){
      # first sample from cells in cluster 1, size cells
      logik = rownames(dat) %in% x$gene
      dummy = dat[logik,]
      logik = as.character(x$cluster[1]) == labels
      dummy = dummy[,logik]
      dd = t(apply(dummy, 1, function(z) {
        sample(z, size = size, replace = T)}))
      dd = t(apply(dd, 1, function(z){
        stats::rnorm(n = length(z), mean = mean(z), sd = sd(z))
      }))
      # now sample from cells in cluster 2, size cells with True Negative Expr.
      logik = !rownames(dat) %in% x$gene
      dummy = dat[logik,]
      logik = as.character(x$cluster[1]) == labels
      dummy = dummy[,logik]
      dd2 = t(apply(dummy, 1, function(z) {
        sample(z, size = size, replace = T)}))
      dd2 = t(apply(dd2, 1, function(z){
        stats::rnorm(n = length(z), mean = mean(z), sd = sd(z))
      }))
      rbind(dd, dd2)
    })
    N2 = merge(N[[1]],N[[2]],by="row.names")
    rownames(N2) <- N2$Row.names
    N2 = t(N2[,-1])
    # normalize
    normalize <- function(x) {
      return ((x - min(x)) / (max(x) - min(x)))
    }
    N2 = apply(N2, 2, function(x){
      normalize(x)
    })
  boot = data.frame(N2, celltypes = c(rep(names(cts)[1], size), rep(names(cts)[2], size)))
  colnames(boot) <- gsub(pattern = "\\.", replacement = "-", x = colnames(boot))
   #pca <- prcomp(x = boot[,-ncol(boot)], center = T, scale. = T) 
   #library(ggfortify)
   #autoplot(pca, data = boot, colour = 'celltypes')
  #library(ggplot2)
  #ggplot(boot, aes(x=FCGR3A, y=GZMH, color=celltypes)) + geom_point()
  #ggplot(boot, aes(x=XCL1, y=XCL2, color=celltypes)) + geom_point()
  
  if (verbose) {
    tb = proc.time()[3] - ta;
    cat("\n ..........  Exit SignacLearn.\n");
    cat("             Execution time = ", tb, " s.\n", sep = "");
  }
  
  return(boot)
}

#' Show hierarchical structure
#'
#' @param R Reference dataset
#' @return annotations by hierarchy
#' @export
ShowHierarchy <- function (R)
{
  df = lapply(1:ncol(R$celltypes), function(x){
    if (x == 1)
    {
      unique(R$celltypes[,x])
    } else {
      logik = R$celltypes[,x] != R$celltypes[,x-1]
      dat = R$celltypes[logik,]
      unique(dat[,x])
    }
  })
  names(df) <- colnames(R$celltypes)
  return(df)
}

#' Load data file from directory
#'
#' @param data.dir Directory containing matrix.mtx and genes.txt.
#' @param mfn file name; default is 'matrix.mtx'
#' @return A sparse matrix with rownames equivalent to the names in genes.txt
#' @export
CID.LoadData <- function(data.dir, mfn = "matrix.mtx")
{
  data.dir = gsub("\\/$", "", data.dir, perl = TRUE);
  if (! (file.exists(paste(data.dir, mfn, sep = "/")) & file.exists(paste(data.dir, "genes.txt", sep = "/"))))
    data.dir = dirname(data.dir)
  gE <- paste(data.dir,mfn,sep="/")
  flag = file.exists(gE);
  if (!flag) {
    cat("ERROR: from CID.LoadData:\n");
    cat("file = ", gE, " does not exist.\n", sep = "");
    stop()
  }
  E <- Matrix::readMM(gE)
  # read genes
  fn <-"genes.txt"
  gG <- paste(data.dir,fn, sep = "/")
  flag = file.exists(gG);
  if (!flag) {
    cat("ERROR: from CID.LoadData:\n");
    cat("file = ", gG, " does not exist.\n", sep = "");
    stop()
  }
  genes <- read.delim(gG, stringsAsFactors = F, header = F)$V1
  if (genes[1] != gsub( "_.*$", "", genes[1] ))
  {
    genes[!grepl("Total", genes)] = gsub( "_.*$", "", genes [!grepl("Total", genes)])
    genes[grepl("Total", genes)]  = gsub( "_", "-",   genes [grepl("Total", genes)])
  }
  if (any(grepl(pattern = "-ENSG00", x = genes)))
  {
    genes <-gsub(pattern = "-ENSG00", replacement = "_ENSG00",x = genes, fixed = T)
    genes[!grepl("Total", genes)] = gsub( "_.*$", "", genes [!grepl("Total", genes)])
    genes[grepl("Total", genes)]  = gsub( "_", "-",   genes [grepl("Total", genes)])
  }
  
  if (grepl("^1", genes[1]))
    genes = do.call(rbind, strsplit(genes, " "))[,2]
  flag = length(genes) %in% c(nrow(E), ncol(E));
  if (!flag) {
    cat("ERROR: from CID.LoadData:\n");
    cat("length of genes in genes.txt = ", length(genes), " is not equal to nrow(E) = ", nrow(E), ", or ncol(E) = ", ncol(E), "\n", sep = "");
    stop()
  }
  if (nrow(E) != length(genes))
    E = Matrix::t(E)
  rownames(E) <- genes
  E
}

#' Load edges from edge list
#'
#' @param data.dir A directory where "edges.csv" is located
#' @return The edgelist in data frame format
#' @export
CID.LoadEdges <- function(data.dir)
{
  edges = paste(data.dir, "edges.csv", sep = "/")
  file.exists(edges)
  flag = file.exists(edges);
  if (!flag) {
    cat("ERROR: from CID.LoadEdges:\n");
    cat("edges = ", edges, " does not exist.\n", sep = "");
    stop()
  }
  # read in knn graph edges
  cat(" ..........  Reading in graph edges from edgelist: \n")
  cat("             ", edges, "\n")
  edges <- read.delim(edges,sep = ";" , stringsAsFactors = F, header = F)
  if(min(edges) == 0)
    edges = edges + 1
  colnames(edges) <- c("V1", "V2")
  edges
}

#' Library size normalize
#'
#' @param E Expression matrix
#' @return Normalized expression matrix to mean of total counts
#' @export
CID.Normalize <- function(E)
{
  xx = NULL
  if (!is.null(colnames(E)))
    xx <- colnames(E)
  if (class(E) == "matrix")
  {
    m = Matrix::Matrix(0, ncol(E), ncol(E))
    tots_use = Matrix::colSums(E)
    target_mean = mean(tots_use)
    diag(m) <- target_mean / tots_use
    E = as.matrix(E %*% m)
    if (!is.null(xx))
      colnames(E) <- xx
  } else {
    m = Matrix::Matrix(0, ncol(E), ncol(E))
    tots_use = Matrix::colSums(E)
    target_mean = mean(tots_use)
    diag(m) <- target_mean / tots_use
    E = Matrix::Matrix(E %*% m, sparse = TRUE)
    if (!is.null(xx))
      colnames(E) <- xx
  }
  return(E)
}

#' Reactome Pathway Enrichment
#'
#' @param genes A character vector of gene symbols (ENTREZ gene symbols).
#' @param verbose Code speaks. Default is TRUE.
#' @return Pathway enrichment results
#' @export
PathwayEnrichment <- function(genes, verbose = T)
{
  # check 
  if (verbose)
  {
    cat(" ..........  Entry in PathwayEnrichment \n");
    ta = proc.time()[3];
  }
  
  res = ReactomePA::enrichPathway(genes)
  
  if (verbose)
  {
  tb = proc.time()[3] - ta;
  cat("\n ..........  Exit PathwayEnrichment.\n");
  cat("             Execution time = ", tb, " s.\n", sep = "");
  }
  
  return(res)
}

#' Reactome Pathway Enrichment plotting
#'
#' @param X results of ?PathwayEnrichment 
#' @param N number of pathways to plot
#' @param color Color of dot plot. Default is red.
#' @param qvalueCutoff FDR cutoff. Default is 0.05.
#' @param adj.pvalCutoff Adjusted p-value cutoff. Default is 0.05.
#' @return Pathway enrichment plot
#' @export
PathwayEnrichmentPlot <- function(X, N = 40, color = "red", qvalueCutoff = 0.05, adj.pvalCutoff = 0.05)
{
  data = X@result
  data = data[data$p.adjust < adj.pvalCutoff & data$qvalue < qvalueCutoff, ]
  
  if (N > nrow(data))
    N = nrow(data)
  data = data[1:N, ]
  data$log10FDR = -log10(data$qvalue)
  data = data[order(data$p.adjust, decreasing = T),]
  data$Description = factor(data$Description, levels = data$Description[order(data$p.adjust, decreasing = T)])
  # Plot
  ggplot2::ggplot(data, ggplot2::aes_string(x="Description", y="log10FDR")) + 
    ggplot2::geom_point(stat='identity', ggplot2::aes_string(size="Count"), color = color)  +
    ggplot2::ylab("-log10 FDR") + ggplot2::xlab("Pathway") +
    ggplot2::geom_hline(yintercept = 1.3, linetype = "dashed") + 
    ggplot2::coord_flip() + ggplot2::theme_bw()
}

#' Convert gene ids
#'
#' @param genestoconvert A character vector of N gene names (HUGO gene symbols)
#' @param from Default is hugo gene symbols. Anything besides "hugo" will assune ENTREZ gene symbols.
#' @return A data frame containing the converted gene names
#' @export
geneconversion <- function(genestoconvert, from = "hugo") {
  
  hs <- org.Hs.eg.db::org.Hs.eg.db
  if (from == "hugo")
  {
    convertedgenes = suppressMessages(AnnotationDbi::select(hs, 
                            keys = genestoconvert,
                            columns = c("ENTREZID", "SYMBOL"),
                            keytype = "SYMBOL"))
  } else {
    convertedgenes = suppressMessages(AnnotationDbi::select(hs, 
                            keys = genestoconvert,
                            columns = c("ENTREZID", "SYMBOL"),
                            keytype = "ENTREZID"))
  }

  return(convertedgenes)
}

#' K soft imputation
#'
#' @param E A gene-by-sample count matrix (sparse matrix, matrix, or data.frame) with genes identified by their HUGO symbols (see ?CID.geneconversion), or a list of such matrices, see ?CID.BatchMode.
#' @param dM see ?CID.GetDistMat
#' @param genes.to.use a character vector of genes to impute. Default is NULL.
#' @param do.save If TRUE, imputed matrix is saved in directory. Default is FALSE.
#' @param verbose If TRUE, code reports outputs.
#' @return Imputed values for every gene
#' @export
KSoftImpute <- function(E,  dM = NULL, genes.to.use = NULL, do.save = F, verbose = T)
{
  # check inputs
  if (verbose)
  {
    cat(" ..........  Entry in KSoftImpute \n");
    ta = proc.time()[3];
    
    # main function
    cat(" ..........  Running K soft imputation on input data matrix :\n");
    cat("             nrow = ", nrow(E), "\n", sep = "");
    cat("             ncol = ", ncol(E), "\n", sep = "");
  }
  
  if (!is.null(genes.to.use))
    E = E[rownames(E) %in% genes.to.use,]
  
  # define the weight matrix Wjj, which is the number of genes detected in each cell
  weights = Matrix::colSums(E != 0)
  bas = Matrix::Matrix(0, nrow = length(weights), ncol = length(weights))
  diag(bas) <- weights
  
  # if is null data.dir, run PCA + KNN
  if (is.null(dM))
  {
    dM = CID.GetNeighbors(E, normalize = T, min_counts = 3, min_cells = 3, min_vscore_pctl = 85, num_pc = 30, k_neigh = 3)
    dM = CID.GetDistMat(dM)
  }
  
  #g = dM[[1]] %*% bas + 1/2 * dM[[2]] %*% bas
  g = dM[[1]] %*% bas 
  dd = g / (Matrix::rowSums(g) + 1)
  diag(dd) <- 1
  E_new = E %*% dd;
  # E_new = CID.Normalize(E_new)
  
  if (do.save)
  {
    data.dir = dirname(data.dir)
    Matrix::writeMM(Matrix::Matrix(E_new, sparse = TRUE), file = paste(data.dir, "matrix_ksoft_imputed.mtx", sep = "/"))
    write.table(rownames(E_new), file = paste(data.dir, "genes_ksoft_imputed.txt", sep = "/"))
  }
  
  if (verbose) {
    tb = proc.time()[3] - ta;
    cat("\n ..........  Exit KSoftImpute.\n");
    cat("             Execution time = ", tb, " s.\n", sep = "");
  }
  
  return(E_new)
}

#' Get edges that are either pre-computed, or generate new edges
#'
#' @param data.dir directory
#' @param E see Signac
#' @return edges for cell-cell similarity network
#' @export
CID.GetEdges <- function(E = NULL, data.dir = NULL)
{
  if (is.null(data.dir))
  {
    edges = CID.GetNeighbors(E, normalize = T, min_counts = 3, min_cells = 3, min_vscore_pctl = 85, num_pc = 30, k_neigh = 4)
  } else {
    edges = CID.LoadEdges(data.dir)
  }
  return(edges)
}

#' Get indices of training markers
#'
#' @param E A gene-by-sample count matrix (sparse matrix, matrix, or data.frame) with genes identified by their HUGO symbols (see ?CID.geneconversion), or a list of such matrices, see ?CID.BatchMode.
#' @param data.dir if default, uses the standard Signac markers (see ?CID.SeeMarkers).
#' @param method.use either 'max.genes.detected' or 'min.entropy'
#' @return a list of cell indices and names to use for training set
#' @export
CID.GetTrainingSet <- function(E, data.dir = NULL, method.use = "max.genes.detected")
{
  inputs = match.call()
  
  if (method.use == "min.entropy")
  {
    # get edges for cell-cell similarity network
    edges = CID.GetEdges(inputs)
    
    # compute distance matrix
    distM = CID.GetDistMat(edges = edges)
    
    # Calculate normalized shannon entropy for each cell j for all connections with shortest path < N
    shannon = rep(0, ncol(E))
    ac = colnames(E)
    
    if (class(distM) == "list")
    {
      dM = Reduce('+', distM) > 0;
      # create identity matrix to subtract off self
      I <- methods::new("ngTMatrix", 
                        i = as.integer(1:nrow(dM) - 1L), 
                        j = as.integer(1:nrow(dM) - 1L),
                        Dim = as.integer(c(nrow(dM), nrow(dM))))
      dM = dM - I
    } else {
      dM = distM
    }
    
    # create matrix for cell labels 
    m = Matrix::Matrix(0, nrow = length(ac), ncol = length(unique(ac)), sparse = T)
    m[cbind(1:nrow(m), as.numeric(factor(ac)))] <- 1
    
    res = dM %*% m
    res = res / Matrix::rowSums(res)
    N_unique = length(unique(ac))
    shannon = apply(res, 1, function(freqs) {-sum(freqs[freqs != 0] * log(freqs[freqs != 0])) / log(2) / log2(N_unique)})
    
    df = data.frame(cells = ac, entropy = shannon)
    
    q = lapply(unique(df$cells), function(x){
      which(df$cells == x)[order(df$entropy[df$cells == x])[1:round(sum(df$cells == x) * 0.5)]]
    })
    names(q) <- unique(df$cells)
    
    idx = which(names(q) == "Unclassified")
    q[-idx]
  }
  
  if (method.use == "max.genes.detected") {
    ac = colnames(E)
    
    total_counts = Matrix::colSums(E != 0)
    
    df = data.frame(cells = ac, entropy = total_counts)
    
    q = lapply(unique(df$cells), function(x){
      which(df$cells == x)[order(df$entropy[df$cells == x], decreasing = TRUE)[1:round(0.5 * sum(df$cells == x))]]
    })
    names(q) <- unique(df$cells)
    
  }
  
  return(q)
}

#' Smoothing function
#'
#' @param ac List containing a character vector where each element is a cell type or cell state assignment
#' @param dM Distance matrix (see ?CID.GetDistMat)
#' @return Smoothed cell type or cell state assignments
#' @export
CID.smooth <- function(ac,dM)
{
  Y = ac;
  # remove any unconnected cells from consideration
  logik = Matrix::rowSums(dM) != 0
  if(any(!logik)){
    dM = dM[logik,logik]
    Y = Y[logik]
  }
  if (sum(dM) == 0)
    return(ac)
  m = Matrix::Matrix(0, nrow = length(Y), ncol = length(unique(Y)), sparse = T)
  m[cbind(1:nrow(m), as.numeric(factor(Y)))] <- 1
  res = dM %*% m
  res = res / Matrix::rowSums(res)
  mx.idx = apply(res, 1, function(x) which.max(x))
  mx = apply(res, 1, max)
  Y[mx > 0.5] = levels(factor(Y))[mx.idx[mx > 0.5]]
  ac[logik] = Y
  return(ac)
}

#' Entropy
#' 
#' @param ac A character vector of cell type labels
#' @param distM The distance matrix, see ?CID.GetDistMat
#' @export
CID.entropy <- function(ac,distM)
{
  # "Y" labels will be ac but with some "Unclassifieds"
  Y   = ac
  
  # Calculate normalized shannon entropy for each cell j for all connections with shortest path < N
  shannon = rep(0, length(Y))
  if (class(distM) == "list")
  {
    dM = Reduce('+', distM) > 0;
    # create identity matrix to subtract off self
    I <- methods::new("ngTMatrix", 
                      i = as.integer(1:nrow(dM) - 1L), 
                      j = as.integer(1:nrow(dM) - 1L),
                      Dim = as.integer(c(nrow(dM), nrow(dM))))
    dM = dM - I
  } else {
    dM = distM
  }
  
  # create matrix for cell labels 
  m = Matrix::Matrix(0, nrow = length(ac), ncol = length(unique(ac)), sparse = T)
  m[cbind(1:nrow(m), as.numeric(factor(ac)))] <- 1
  
  res = dM %*% m
  res = res / Matrix::rowSums(res)
  N_unique = length(unique(Y))
  shannon = apply(res, 1, function(freqs) {-sum(freqs[freqs != 0] * log(freqs[freqs != 0])) / log(2) / log2(N_unique)})
  
  #df = data.frame(cells = Y, entropy = shannon)
  #ggplot(df, aes(x=cells, y=entropy, fill = cells)) + geom_boxplot()
  q = c(shannon, -shannon)
  # note symmetry
  # hist(q)
  # use Gaussian
  
  Y[shannon > 2 * sd(q)] = "Unclassified"
  
  #df = data.frame(cells = Y, entropy = shannon)
  #ggplot(df, aes(x=cells, y=entropy, fill = cells)) + geom_boxplot()
  
  return(Y)
}

#' Write JSON file for SPRING visualization
#'
#' @param cr Output from CID.CellID. See ?CID.CellID
#' @param json_new Filename for new SPRING visualization. Default is json_new = "categorical_coloring_data_new.json".
#' @param data.dir Directory where file 'categorical_coloring_data.json' is located. If supplied, it will append this file to contain tracks for cell type / state classifications.
#' @param new_populations Character vector specifying any new cell types that Signac has learned. Default is NULL.
#' @param new_colors Character vector specifying the HEX color codes for new cell types. Default is NULL.
#' @return Smoothed cell type or cell state assignments
#' @export
CID.writeJSON <- function(cr, json_new = "categorical_coloring_data.json", data.dir, new_populations = NULL, new_colors = NULL)
{
  if (!is.null(data.dir))
  {
    data.dir = gsub("\\/$", "", data.dir, perl = TRUE);
    if (file.exists(paste(data.dir, 'categorical_coloring_data.json', sep = "/")))
    {
      json_file = 'categorical_coloring_data.json'
      gJ <- paste(data.dir,json_file,sep = "/")
      json_data <- RJSONIO::fromJSON(gJ)
      json_out = jsonlite::toJSON(json_data, auto_unbox = TRUE)
      write(json_out,paste(data.dir,'categorical_coloring_data_legacy.json',sep="/"))
    } else {
      json_file = 'categorical_coloring_data_old.json'
      gJ <- paste(data.dir,json_file,sep = "/")
      json_data <- RJSONIO::fromJSON(gJ)
      json_out = jsonlite::toJSON(json_data, auto_unbox = TRUE)
      write(json_out,paste(data.dir,'categorical_coloring_data_legacy.json',sep="/"))
    }
  }
  if ("clusters" %in% names(cr))
  {
    Q = as.character(cr$clusters)
    json_data$Clusters_Louvain$label_list = Q
    Ntypes = length(unique(Q))
    qual_col_pals = RColorBrewer::brewer.pal.info[RColorBrewer::brewer.pal.info$category == 'qual',]
    col_vector = unlist(mapply(RColorBrewer::brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) #len = 74
    #pie(rep(1,num_col), col=(col_vector[1:num_col]))
    col_palette <- as.list(col_vector[1:Ntypes]); # or sample if you wish
    names(col_palette) <- unique(Q)
    json_data$Clusters_Louvain$label_colors = col_palette
  }
  if ("CellTypes" %in% names(cr))
  {
    Q = cr$CellTypes
    json_data$CellTypes$label_list = Q
    C = get_colors(Q)
    json_data$CellTypes$label_colors = as.list(C[[1]])
  }
  if ("CellStates" %in% names(cr))
  {
    Q = cr$CellStates
    json_data$CellStates$label_list = Q
    C = get_colors(Q)
    json_data$CellStates$label_colors = as.list(C[[1]])
  }
  if ("CellTypes_novel" %in% names(cr))
  {
    Q = cr$CellTypes_novel
    json_data$CellTypes_novel$label_list = Q
    C = get_colors(Q)
    Ntypes = sum(C[[1]] == "")
    qual_col_pals = RColorBrewer::brewer.pal.info[RColorBrewer::brewer.pal.info$category == 'qual',]
    col_vector = unlist(mapply(RColorBrewer::brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) #len = 74
    #pie(rep(1,num_col), col=(col_vector[1:num_col]))
    C[[1]][C[[1]] == ""] <- col_vector[1:Ntypes]; # or sample if you wish
    json_data$CellTypes_novel$label_colors = as.list(C[[1]])
  }
  if ("CellStates_novel" %in% names(cr))
  {
    Q = cr$CellStates_novel
    json_data$CellStates_novel$label_list = Q
    C = get_colors(Q)
    Ntypes = sum(C[[1]] == "")
    qual_col_pals = RColorBrewer::brewer.pal.info[RColorBrewer::brewer.pal.info$category == 'qual',]
    col_vector = unlist(mapply(RColorBrewer::brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) #len = 74
    #pie(rep(1,num_col), col=(col_vector[1:num_col]))
    C[[1]][C[[1]] == ""] <- col_vector[1:Ntypes]; # or sample if you wish
    json_data$CellStates_novel$label_colors = as.list(C[[1]])
  }
  if ("Immune" %in% names(cr))
  {
    Q = cr$Immune
    json_data$Immune$label_list = Q
    C = get_colors(Q)
    json_data$Immune$label_colors = as.list(C[[1]])
  }
  json_data = json_data[order(names(json_data))]
  json_data_backup = json_data;
  if (!is.null(new_populations)) {
    json_data = lapply(json_data, function(x) {
        for (j in 1:length(new_populations))
          x$label_colors[names(x$label_colors) == new_populations[j]] = new_colors[j]
        x
    })
  }
  fn = json_new
  json_out = jsonlite::toJSON(json_data, auto_unbox = TRUE)
  write(json_out,paste(data.dir,fn,sep="/"))
  cat(paste(data.dir,fn,sep="/"), "has been written to directory! \n")
  return(json_data)
}

#' Get HEX colors
#' 
#' @param P A character vector of cell type labels
get_colors <- function(P)
{
  P <- sort(unique(as.character(P)));
  colorcount = length(unique(P))
  cs = character(colorcount)
  # main cell type categories will be consistently labeled:
  main_types = c("B"     ,     "Epithelial", "Fibroblasts"        ,
                 "MPh"         , "Plasma.cells"  , "Endothelial",
                 "TNK"         ,     "Unclassified"     , "NonImmune"          ,
                 "Immune")
  main_colors = c("#aa3596"     ,     "#387f50"   , "#a2ba37" ,
                  "#f1ff51"     ,     "#d778de"   , "#73de97" ,
                  "#90c5f4"     ,     "#c0c0c0"   , "#7fc97f" ,
                  "#bb7fc7" )
  
  # sub cell types will be consistently labeled:
  sub_types  = c("B.memory", "B.naive", "DC"    , "Macrophages", "Mon.Classical", "Mon.NonClassical", "Monocytes", "Neutrophils", "NK", "T.CD4.memory", "T.CD4.naive", "T.CD8.cm", "T.CD8.em", "T.CD8.naive", "T.gd", "T.regs" )
  sub_colors  = c("#aa3596", "#edc5e6", "#f9a702" , "#f97501", "#d6b171", "#9e4c05", "#f1ff51", "#f7f2b2", "#ac9bf2", "#bb7fc7", "#8a5e83", "#c9c9ff", "#8c9fe1", "#90c5f4", "#64058a", "#2038b0" )
  
  for (i in 1:length(sub_types))
  {
    cs[P == sub_types[i]] = sub_colors[i]
    cs[P == main_types[i]] = main_colors[i]
  }
  
  cs[P == "None"] = "#808080"
  
  outs = list(cs)
  
  names(outs[[1]]) <- P
  
  return(outs)
}

#' Community substructure by Louvain community detection
#'
#' @param edges A data frame or matrix with edges
#' @return The community substructures of the graph
#' @export
CID.Louvain <- function(edges)
{
  # convert edgelist to adjacency matrix
  if (nrow(edges) != ncol(edges))
  {
    adjmatrix <- methods::new("ngTMatrix", 
                              i = c(as.integer(edges$V1)-1L, as.integer(edges$V2)-1L), 
                              j = c(as.integer(edges$V2)-1L, as.integer(edges$V1)-1L),
                              Dim = as.integer(c(max(edges), max(edges))))
  } else {
    adjmatrix = edges; # just load straight adjacency matrix 
  }
  g = igraph::graph_from_adjacency_matrix(adjmatrix * 1, mode = c("undirected"), weighted = NULL, diag = TRUE, add.colnames = NULL, add.rownames = NA)
  as.character(igraph::cluster_louvain(g)$membership)
}

#' Get distance matrix
#'
#' @param edges a data frame with two columns; V1 and V2, specifying the cell-cell edge list for the network
#' @param n maximum network distance to subtend (n neighbors)
#' @return adjacency matrices for distances < n
#' @export
CID.GetDistMat <- function(edges, n = 4)
{
  "%^%" <- function(A, n) {if(n == 1) A else A %*% (A %^% (n-1)) }
  # create adjacency matrix
  if (nrow(edges) != ncol(edges))
  {
    m <- methods::new("ngTMatrix", 
                      i = c(as.integer(edges$V1)-1L, as.integer(edges$V2)-1L), 
                      j = c(as.integer(edges$V2)-1L, as.integer(edges$V1)-1L),
                      Dim = as.integer(c(max(edges), max(edges))))
  } else {
    m = edges
  }
  
  dm = list("") # initialize distance matrix
  for (j in 1:n)
    if(j == 1) dm[[j]] = m else dm[[j]] = m %^% j
  return(dm)
}

#' Get main cell types from hierarchy
#'
#' @param R reference matrix 
#' @return a vector of cell type identities given the hierarchy
#' @export
get_celltypes <- function(R) {
  
  # we need to populate a data frame with labels at each level of the hierarchy
  celltypes = unique(unlist(R$immune_hierarchy, use.names = F)) # bottom level
  qq = do.call(c, unlist(R$immune_hierarchy, recursive=FALSE))
  
  # construct a data frame from the list
  R$immune_hierarchy[names(R$immune_hierarchy)]

}

#' Extract unique elements
#'
#' @param x A character vector 
#' @return boolean, unique elements are TRUE
#' @export
CID.IsUnique <- function (x) 
{
  rv = rep(TRUE, length(x))
  if (length(x) >= 2) {
    ord = order(x)
    ox = x[ord]
    neq = (ox[-length(ox)] != ox[-1])
    rv[ord] = c(neq, TRUE) & c(TRUE, neq)
  }
  return(rv)
}

#' Get positive genes by z-score
#'
#' @param D Expression matrix with genes for rows, samples for columns
#' @param acn Vector of cell type labels 
#' @return List where each element contains the z score for the one vs. all comparison
#' @export
CID.PosMarkers2 <- function(D, acn)
{
  cts = unique(colnames(D));
  cts = cts[cts != "All"]
  mrks = list("")
  new_lbls = list("")
  
  # remove MT- and RP genes
  logik = grepl("^MT-", rownames(D)) | grepl("^RP", rownames(D))
  D = D[!logik,]
  
  # establish all means
  if ("All" %in% colnames(D))
  {
    all_means = Matrix::rowMeans(D[,colnames(D) == "All"])
    
    mrks = lapply(cts, function(x){
      logik = colnames(D) == x
      if (sum(logik) > 200)
        logik = 1:ncol(D) %in% sample(which(colnames(D) == x), 200)
      kmu = Matrix::rowMeans(D[,logik])
      s  = apply(D[, logik], 1, sd)
      ff = (kmu - all_means) / (s + 0.02)
      ff = sort(ff, decreasing = T)
      return(ff)
    })
    names(mrks) <- cts
    
    new_lbls = lapply(mrks, function(x){
      gns = names(x)[1:2]
      paste("+", gns, collapse = " ", sep = "")
    })
    
    names(new_lbls) <- cts
    names(mrks) <- cts
    
    Y = acn
    
    for (j in 1:length(new_lbls))
      Y[colnames(D) == names(new_lbls)[j]] = new_lbls[[j]]
  } else {
    mrks = lapply(cts, function(x){
      logik = colnames(D) == x
      if (sum(logik) > 200)
        logik = 1:ncol(D) %in% sample(which(colnames(D) == x), 200)
      kmu = Matrix::rowMeans(D[,logik])
      all_means = Matrix::rowMeans(D[,!logik])
      s  = apply(D[, logik], 1, sd)
      ff = (kmu - all_means) / (s + 0.02)
      ff = sort(ff, decreasing = T)
      return(ff)
    })
    names(mrks) <- cts
    
    new_lbls = lapply(mrks, function(x){
      gns = names(x)[1:2]
      paste("+", gns, collapse = " ", sep = "")
    })
    
    names(new_lbls) <- cts
    names(mrks) <- cts
    
    Y = acn
    
    for (j in 1:length(new_lbls))
      Y[colnames(D) == names(new_lbls)[j]] = new_lbls[[j]]
  }
  
  return(list(lbls = Y, mrks = mrks))
}

#' Get KNN edges from single cell data
#'
#' @param E Expression matrix with genes for rows, samples for columns
#' @param normalize Normalize expression matrix to mean counts per cell. Default is FALSE.
#' @param min_counts minimum number of counts per cell. Default is 3.
#' @param min_cells minimum bumber of cells expressing at least min_counts. Default is 3.
#' @param min_vscore_pctl Minimum v score percentile for genes to run with PCA. Default is 90.
#' @param num_pc Number of PCs to build the KNN graph. Default is 50. 
#' @param k_neigh k parameter in KNN. Default is 4.
#' @param genes_use if desired, manually set the genes for PCA
#' @return List where each element contains the DEG tables for the one vs. all comparison
#' @export
CID.GetNeighbors <- function(E, normalize = F, min_counts = 3, min_cells = 3, min_vscore_pctl = 85, num_pc = 30, k_neigh = 4, genes_use = NULL)
{
  cat(" ..........  Entry in CID.GetNeighbors \n");
  ta = proc.time()[3];
  
  if (normalize)
  {
    cat('             Normalizing \n')
    E = CID.Normalize(E)
  }
  
  if (is.null(genes_use))
  {
    cat('             Filtering genes \n')
    
    # Get gene stats (above Poisson noise, i.e. V-scores)
    outs = get_vscores_sparse(E)
    gene_ix = outs$gene_ix
    Vscores = outs$v_scores
    ix2 = Vscores>0
    gene_ix = gene_ix[ix2]
    
    # Filter genes: minimum V-score percentile and at least min_counts in at least min_cells
    min_log_vscore = quantile(log(Vscores), min_vscore_pctl/100)
    
    ix = (Matrix::rowSums(E[gene_ix,] >= min_counts) >= min_cells) & (log(Vscores) >= min_log_vscore)
    cat('             Using ', sum(ix), "genes \n")
    
    genes_use = rownames(E)[ix]
  }
  
  outs = get_knn_graph2(E, k=k_neigh, np=num_pc,genes_to_use=genes_use)
  
  outs = igraph::graph.adjacency(outs, diag = F)
  outs = igraph::get.data.frame(outs)
  outs = data.frame(apply(outs, 2, as.numeric))
  colnames(outs) <- c("V1", "V2")
  
  tb = proc.time()[3] - ta;
  cat("\n ..........  Exit CID.GetNeighbors.\n");
  cat("             Execution time = ", tb, " s.\n", sep = "");
  
  return(outs)
}

#' Get V scores
#'
#' @param E Expression matrix with genes for rows, samples for columns
#' @param min_mean Minimum mean gene expression. Default is zero.
#' @param nBins Number of bins for histogram binning. Default is 50.
#' @param fit_percentile Percentile for fitting. Default is 0.1.
#' @param error_wt Error for convergence of optimization. Default is 1.
#' @return V scores for each gene in the expression matrix E.
get_vscores_sparse <- function(E, min_mean=0, nBins=50, fit_percentile=0.1, error_wt=1)
{ 
  ncell = ncol(E)
  
  mu_gene = Matrix::rowMeans(E)
  gene_ix = mu_gene > min_mean
  mu_gene = mu_gene[gene_ix]
  tmp = E[gene_ix,]
  var_gene = Matrix::rowMeans(tmp ^ 2) - mu_gene ^ 2
  FF_gene = var_gene / mu_gene
  
  data_x = log(mu_gene)
  data_y = log(FF_gene / mu_gene)
  
  outs = runningquantile(data_x, data_y, fit_percentile, nBins)
  x = outs$xOut
  y = outs$yOut
  x = x[!is.na(x)]
  y = y[!is.na(y)]
  
  gLog <- function(input) {
    log(input[[2]] * exp(-input[[1]]) + input[[3]])
  }
  d = hist(log(FF_gene[mu_gene>0]), breaks=seq(min(log(FF_gene[mu_gene>0])), max(log(FF_gene[mu_gene>0])),length.out = 201), plot = F, warn.unused = F)
  h = d$counts
  b = d$breaks
  b = b[-length(b)] + diff(b)/2
  max_ix = which.max(h)
  c = max(exp(b[max_ix]))
  errFun <- function(b2) {
    sum(abs(gLog(list(x,c,b2))-y) * error_wt)
  }
  b0 = 0.1
  b = optimize(f = errFun, interval = c(0,1))$minimum
  a = c / (1 + b) - 1
  v_scores = FF_gene / ((1+a)*(1+b) + b * mu_gene);
  outs = list(v_scores = v_scores, gene_ix = gene_ix)
  return(outs)
}

#' Compute variance for sparse matrices.
#'
#' @param E Expression matrix with genes for rows, samples for columns
sparse_var <- function(E)
{
  mean_gene = Matrix::rowMeans(E)
  tmp = E;
  tmp = tmp ^ 2;
  return(Matrix::rowMeans(tmp) - mean_gene ^ 2)
}

#' Compute running quantile
#'
#' @param x log of mean gene expression.
#' @param y log of fano factor divided by mean gene expression.
#' @param p fit_percentile as defined in get_vscores_sparse
#' @param nBins number of bins for histogram binning
runningquantile <- function(x, y, p, nBins)
{
  ind = order(x)
  x = x[ind]
  y = y[ind]
  
  dx = (x[length(x)] - x[1]) / nBins
  xOut = seq(x[1]+dx/2, x[length(x)]-dx/2, length.out = nBins)
  
  yOut = matrix(0, 1, length(xOut))
  
  for (i in 1:length(xOut))
  {
    ind = (x >= xOut[i]-dx/2) & (x < xOut[i]+dx/2)
    if (sum(ind) > 0)
    {
      yOut[i] = quantile(y[ind], p)
    } else {
      if (i > 0)
      {
        yOut[i] = yOut[i-1]
      } else {
        yOut[i] = NA
      }
    }
  }
  return(list(xOut = xOut, yOut = yOut))
}

#' Get KNN graph
#'
#' @param X Expression matrix with genes for rows, samples for columns, after V score filtering.
#' @param k KNN parameter. Default is 5.
#' @param np Number of PCs to build the KNN graph. Default is 50.
#' @param genes_to_use gene list for KNN graph building
get_knn_graph2 <- function(X, k=4, np, genes_to_use)
{
  logik = CID.IsUnique(rownames(X))
  X = X[logik,]
  colnames(X) <- 1:ncol(X)
  ctrl <- suppressWarnings(Seurat::CreateSeuratObject(X))
  ctrl <- Seurat::ScaleData(ctrl, verbose = F)
  ctrl <- Seurat::RunPCA(ctrl, features = genes_to_use, pcs.compute = np, do.print = F)
  ctrl <- Seurat::FindNeighbors(object = ctrl, reduction = "pca", dims = 1:min(c(np, 50)), k.param = k)
  return(ctrl@graphs$RNA_nn)
}

#' Save network h5 files
#'
#' @param A an adjacency matrix with row names and columns names genes (gene by gene)
#' @param data.dir directory where the networks are saved
#' @return a saved network file
#' @export
SaveNetworksH5 <- function(A, data.dir)
{
  if (!requireNamespace("rhdf5", quietly = TRUE))
    stop("Please install rhdf5 to save HDF5 files")
data.dir = gsub("\\/$", "", data.dir, perl = TRUE);
    
if (!dir.exists(data.dir))
  dir.create(data.dir)
    
if (!"list" %in% class(A))
  A = list(A)
    
    cat(" ..........  Entry in SaveNetworkH5: \n");
    ta = proc.time()[3];
    cat("             Number of genes:", nrow(A[[1]]), "\n");
    cat("             Number of networks:", length(A), "\n");
    
    if (is.null(names(A)))
      names(A) <- paste0("Network", seq_along(1:length(A)))
    
    data.dirs = paste(data.dir, names(A), sep = "/")
    
    q = lapply(data.dirs, function(x){
      if (!dir.exists(x))
        dir.create(x)})
    
    d = suppressWarnings(
      mapply(function(x,y){
        fn = "network_sparse_genes.h5"
        fn = paste(y, fn, sep = "/")
        rhdf5::h5createFile(fn)
        rhdf5::h5createGroup(fn, "edges")
        lapply(rownames(x), function(y){
          edges = which(x[rownames(x) == y,] != 0)
          rhdf5::h5write.default(edges, file = fn, name = paste0("edges/", y))
        })
        rhdf5::h5write.default(dim(x), file = fn, name="shape")
      }, x = A, y = data.dirs)
    )
    
    d = suppressWarnings(
      mapply(function(x,y){
        fn = "network_total.h5"
        fn = paste(y, fn, sep = "/")
        rhdf5::h5createFile(fn)
        rhdf5::h5write.default(x@Dimnames[[2]], file = fn, name = "genes")
        rhdf5::h5write.default(x@x, file = fn, name = "data")
        rhdf5::h5write.default(dim(x), file = fn, name="shape")
        rhdf5::h5write.default(x@i, file = fn, name="indices") # already zero-indexed.
        rhdf5::h5write.default(x@p, file = fn, name="indptr")
      }, x = A, y = data.dirs))
    
    rhdf5::h5closeAll()
    tb = proc.time()[3] - ta;
    cat(" ..........  Exit SaveNetworksH5 \n");
    cat("             Execution time = ", tb, " s.\n", sep = "");
}

#' Load gene from network h5 file
#'
#' @param gene A gene to query from the network
#' @param filename file name of network. Default is "network.hdf5"
#' @return a saved network file
#' @export
GetGeneFromNetwork <- function(gene, filename = "network_sparse_genes.h5")
{
  if (!requireNamespace("hdf5r", quietly = TRUE))
    stop("Please install hdf5r to read HDF5 files")
  if (!file.exists(filename))
    stop("File not found")
  infile = hdf5r::H5File$new(filename)
  E = Matrix::Matrix(0, ncol = 1, nrow = length(names(infile[["edges"]])), sparse = T)
  nodes <- infile[[paste("edges/", gene, sep = "/")]][]
  E[nodes] = 1
  #E = as.matrix(E)
  rownames(E) <- names(infile[["edges"]])
  return(E)
}

#' Load gene from network h5 file
#'
#' @param filename file name of network. Default is "network.hdf5"
#' @return a saved network file
#' @export
GetGeneListFromNetwork <- function(filename = "network.h5")
{
  if (!requireNamespace("hdf5r", quietly = TRUE))
    stop("Please install hdf5r to read HDF5 files")
  if (!file.exists(filename))
    stop("File not found")
  infile = hdf5r::H5File$new(filename)
  return(names(infile[["edges"]]))
}

#' Load gene from network h5 file
#'
#' @param filename file name of network. Default is "network.hdf5"
#' @return a saved network file
#' @export
LoadNetwork <- function(filename = "network_total.h5")
{
  if (!requireNamespace("hdf5r", quietly = TRUE)) {
    stop("Please install hdf5r to read HDF5 files")
  }
  if (!file.exists(filename)) {
    stop("File not found")
  }
  infile <- hdf5r::H5File$new(filename)
  
  counts <- infile[["data"]]
  indices <- infile[["indices"]]
  indptr <- infile[["indptr"]]
  features <- infile[["genes"]][]
  sparse.mat <- Matrix::sparseMatrix(i = indices[] + 1, p = indptr[],
                                     x = as.numeric(counts[]), dims = c(length(features), length(features)), giveCsparse = FALSE)
  rownames(sparse.mat) <- features
  colnames(sparse.mat) <- features
  sparse.mat <- as(object = sparse.mat, Class = "dgCMatrix")
 
  return(sparse.mat)
  
}

#' Write results to a folder
#'
#' @param D A list of count matrices
#' @param data.dir directory (will be created if it does not exist) where results are saved
#' @param genome default is GRCh38.
#' @importFrom methods as
#' @importClassesFrom Matrix dgCMatrix
#' @return matrix.h5 file, where each is background corrected
#' @export
#' @importFrom rhdf5 h5createFile h5createGroup h5write h5write.default
SaveCountsToH5 <- function(D, data.dir, genome = "GRCh38")
{
  
  data.dir = gsub("\\/$", "", data.dir, perl = TRUE);
  
  if (!dir.exists(data.dir))
    dir.create(data.dir)
  
  if (!"list" %in% class(D))
    D = list(D)
  
  cat(" ..........  Entry in SaveCountsToH5: \n");
  ta = proc.time()[3];
  cat("             Number of cells:", sum(sapply(D, ncol)), "\n");
  cat("             Number of genes:", nrow(D[[1]]), "\n");
  cat("             Number of samples:", length(D), "\n");
  
  if (is.null(names(D)))
    names(D) <- paste0("Sample", seq_along(1:length(D)))
  
  flag = rownames(D[[1]])[1] != gsub( "_.*$", "", rownames(D[[1]])[1])
  
  if (flag)
  {
    genes = strsplit(x = rownames(D[[1]]), split = "_._")
    gene_names = sapply(genes, `[[`, 1)
    genes = sapply(genes, `[[`, 2)
  }
  
  D = lapply(D, function(x)
  {
    x@Dimnames[[1]] = rownames(D[[1]])
    x
  })
  
  data.dirs = paste(data.dir, names(D), sep = "/")
  
  q = lapply(data.dirs, function(x){
    if (!dir.exists(x))
      dir.create(x)})
  
  d = suppressWarnings(
    mapply(function(x,y){
      fn = "count_matrix.h5"
      fn = paste(y, fn, sep = "/")
      rhdf5::h5createFile(fn)
      rhdf5::h5createGroup(fn, genome)
      rhdf5::h5write.default(x@Dimnames[[2]], file = fn, name = paste0(genome, "/barcodes"))
      if (flag)
      {
        rhdf5::h5write.default(genes, file = fn, name=paste0(genome, "/genes"))
        rhdf5::h5write.default(gene_names, file = fn, name=paste0(genome, "/gene_names"))
      } else {
        rhdf5::h5write.default(x@Dimnames[[1]], file = fn, name=paste0(genome, "/genes"))
        rhdf5::h5write.default(x@Dimnames[[1]], file = fn, name=paste0(genome, "/gene_names"))
      }
      rhdf5::h5write.default(x@x, file = fn, name=paste0(genome, "/data"))
      rhdf5::h5write.default(dim(x), file = fn, name=paste0(genome, "/shape"))
      rhdf5::h5write.default(x@i, file = fn, name=paste0(genome, "/indices")) # already zero-indexed.
      rhdf5::h5write.default(x@p, file = fn, name=paste0(genome, "/indptr"))
    }, x = D, y = data.dirs)
  )
  rhdf5::h5closeAll()
  tb = proc.time()[3] - ta;
  cat(" ..........  Exit SaveCountsToH5 \n");
  cat("             Execution time = ", tb, " s.\n", sep = "");
}

#' Generate a network with Graphical LASSO
#'
#' @param E Sparse expression matrix with rows genes and columns cells (see ?Signac)
#' @param gns_of_int <10,000 gene list of genes for network reconstruction
#' @param rho sparsity parameter for graphical LASSO
#' @param metadata data frame with metadata for each cell after signac classification
#' @return network object
#' @export
GenerateNetwork = function(E, gns_of_int, rho = c(0.3, 0.4, 0.5, 0.6), metadata)
{
  # subset expression matrix
  E = E[rownames(E) %in% gns_of_int,]
  
  # build networks around rho
  res = lapply(rho, function(z){
    
    ## seperate two matrices by cell state
    Q = lapply(unique(metadata$CellTypes), function(x) {
      Matrix::t(E[,metadata$CellTypes == x])
    })
    
    ## remove any genes with zero expression
    Q = lapply(Q, function(x) {x[,Matrix::colSums(x) != 0]})
    
    ## remove any cells with zero expression
    Q = lapply(Q, function(x) {x[Matrix::rowSums(x) != 0,]})
    
    # Graphical LASSO using QUIC
    Covs = lapply(Q, function(x){
      stats::cov(as.matrix(x))
    })
    
    Nets = lapply(Covs, function(x){
      glasso::glasso(x, rho = z)
    })
    
    # apply rownames
    Nets = lapply(Nets, function(x) {x$wi})
    Nets = mapply(function(x,y) {
      rownames(x) <- colnames(y)
      colnames(x) <- colnames(y)
      x
    }, x = Nets, y = Q)
    
    names(Nets) <-unique(metadata$CellTypes)
    Nets
  })
  
  # keep stable networks
  N = lapply(res, function(x) {
    lapply(x, function(z){
      1*(z != 0)})
  })
  
  outs = list("")
  for (j in 1:length(res[[1]])){
    outs[[j]] = Reduce("+", lapply(N, function(x){x[[j]]}))
    logik = outs[[j]] == length(rho)
    outs[[j]][logik] = 1
    outs[[j]][!logik] = 0
    outs[[j]] = Matrix::Matrix(outs[[j]], sparse = T)
  }
  
  names(outs) <- names(N[[1]])
  
  # return networks
  return(outs)
}

#' Differential Expression Analysis for reference dataset
#'
#' @param R A reference list as returned by data("Reference_sim")
#' @return a list of DEG tables
#' @export
GetMarkers <- function(R)
{
  E = R$data
  # set colnames
  colnames(E) <- seq(1, ncol(E))
  # Set up object
  outs = lapply(1:ncol(R$celltypes),function(x){
    lbls = R$celltypes[,x]
    if (length(unique(lbls)) == 1)
    {
      return(NULL)
    } else {
      if (x > 1)
      {
        logik = R$celltypes[,x] != R$celltypes[,x-1]
        dat = E[,logik]
        lbls = lbls[logik]
      } else {
        dat = E
        lbls = lbls
      }
      ctrl <- Seurat::CreateSeuratObject(counts = dat, project = "CID", min.cells = 0)
      ctrl <- Seurat::NormalizeData(ctrl, normalization.method = "RC")
      ctrl <- Seurat::AddMetaData(ctrl, metadata=lbls, col.name = "celltypes")
      ctrl <- Seurat::SetIdent(ctrl, value='celltypes')
      Seurat::FindAllMarkers(ctrl, only.pos = T, min.cells.group = 0)
    }
  })
  
  return(outs)
}

#' Differential Expression Analysis
#'
#' @param E A gene by cell expression matrix
#' @param Samples A character vector of samples.
#' @param Identities A character vector of cell type or cluster labels
#' @param Disease A character vector of disease labels
#' @param omit Any samples to omit. Default is "none" and "Empty"
#' @return a DEG table
#' @export
GetAllMarkers <- function(E, Samples = NULL, Disease = NULL, Identities, omit = c("none", "Empty", "Double200-0109&200-0611"))
{
  cat(" ..........  Entry in GetAllMarkers: \n");
  ta = proc.time()[3];
  cat("             Number of cells:", ncol(E), "\n");
  cat("             Number of genes:", nrow(E), "\n");
  
  colnames(E) <- 1:ncol(E)
  
  if (! is.null(Disease))
  {
    if (!is.null(Samples)) {
      logik = !Samples %in% omit
      E = E[,logik]
      Disease = Disease[logik]
      Identities = Identities[logik]
      Samples = Samples[logik]
    }
    
    # create Seurat object for each cell type; run differential expression
    y = as.character(sort(unique(Identities)))
    qq = lapply(y, function(z){
      logik = Identities == z;
      E.          = E[,logik]
      Disease.    = Disease[logik]
      Identities. = Identities[logik]
      if (length(unique(Disease.))!=1) { 
        ctrl <- suppressWarnings(Seurat::CreateSeuratObject(E.))
        ctrl <- Seurat::NormalizeData(object = ctrl, verbose = F)
        ctrl <- Seurat::AddMetaData(ctrl, metadata=Disease., col.name = "Disease")
        ctrl <- Seurat::SetIdent(ctrl, value='Disease')
        dummy = Seurat::FindAllMarkers(ctrl, only.pos = T, verbose = F, min.cells.group = 0, max.cells.per.ident = 500)
        if (nrow(dummy) != 0)
        {
          dummy$celltype = z
          dummy
        } else {
          NULL
        }
      } else {
        NULL
      }
    })
    names(qq) <- y
    
    qq = qq[sapply(qq, function(x){!is.null(x)})]
    
    ## pool together DE results
    df = do.call(rbind, qq)
    names(df) <- c("p_val", "avg_logFC", "pct.1", "pct.2", "p_val_adj", "disease", "gene", "identity")
    df = df[order(df$disease),]
    df$pct.1 = round(df$pct.1, digits = 2) * 100
    df$pct.2 = round(df$pct.2, digits = 2) * 100
    df$avg_logFC = round(df$avg_logFC, digits = 2)
    df$p_val = formatC(df$p_val, format = "e", digits = 2)
    df$p_val_adj = formatC(df$p_val_adj, format = "e", digits = 2)
    rownames(df) <- NULL
    df = data.frame(
      gene = df$gene,
      identity = df$identity,
      disease = df$disease,
      avg_logFC = df$avg_logFC,
      pct.1 = df$pct.1,
      pct.2 = df$pct.2,
      p_val = df$p_val,
      p_val_adj = df$p_val_adj
    )
    df = split.data.frame(df, f = df$identity)
    df = lapply(df, function(x){x[order(x$avg_logFC, decreasing = T),]})
    df = do.call(rbind, df)
    rownames(df) <- NULL
    return(df) 
  } else {
    if (!is.null(Samples)) {
      logik = !Samples %in% omit
      E = E[,logik]
      Identities = Identities[logik]
    }
    
    # create Seurat object for each cell type; run differential expression
    ctrl <- suppressWarnings(Seurat::CreateSeuratObject(E))
    ctrl <- Seurat::NormalizeData(object = ctrl, verbose = F)
    ctrl <- Seurat::AddMetaData(ctrl, metadata=Identities, col.name = "Identities")
    ctrl <- Seurat::SetIdent(ctrl, value='Identities')
    df = Seurat::FindAllMarkers(ctrl, only.pos = T, verbose = F, min.cells.group = 0, max.cells.per.ident = 500)
    
    ## pool together DE results
    names(df) <- c("p_val", "avg_logFC", "pct.1", "pct.2", "p_val_adj", "identity", "gene")
    df = df[order(df$identity),]
    df$pct.1 = round(df$pct.1, digits = 2) * 100
    df$pct.2 = round(df$pct.2, digits = 2) * 100
    df$avg_logFC = round(df$avg_logFC, digits = 2)
    df$p_val = formatC(df$p_val, format = "e", digits = 2)
    df$p_val_adj = formatC(df$p_val_adj, format = "e", digits = 2)
    rownames(df) <- NULL
    df = data.frame(
      gene = df$gene,
      identity = df$identity,
      avg_logFC = df$avg_logFC,
      pct.1 = df$pct.1,
      pct.2 = df$pct.2,
      p_val = df$p_val,
      p_val_adj = df$p_val_adj
    )
    df = split.data.frame(df, f = df$identity)
    df = lapply(df, function(x){x[order(x$avg_logFC, decreasing = T),]})
    df = do.call(rbind, df)
    rownames(df) <- NULL
    return(df) 
  }
  
  tb = proc.time()[3] - ta;
  cat("\n ..........  Exit GetAllMarkers.\n");
  cat("             Execution time = ", tb, " s.\n", sep = "");
}


#' Main function for mixed effect modeling
#'
#' @param dataset data frame of covariate, cell type, clustering or disease information
#' @param cluster celltypes returned by Signac or cluster identities
#' @param contrast Typically disease
#' @param random_effects User specified random effect variables in dataset
#' @param fixed_effects User specific fixed effects in dataset
#' @param verbose If TRUE, algorithm reports outputs
#' @return mixed effect model results
#' @export
MASC <- function(dataset, cluster, contrast, random_effects = NULL, fixed_effects = NULL,
                 verbose = FALSE) {
  # Check inputs
  if (is.factor(dataset[[contrast]]) == FALSE) {
    stop("Specified contrast term is not coded as a factor in dataset")
  }
  
  cat(" ..........  Entry in MASC \n");
  ta = proc.time()[3];
  
  # Generate design matrix from cluster assignments
  cluster <- as.character(cluster)
  designmat <- model.matrix(~ cluster + 0, data.frame(cluster = cluster))
  dataset <- cbind(designmat, dataset)
  
  # Convert cluster assignments to string
  cluster <- as.character(cluster)
  # Prepend design matrix generated from cluster assignments
  designmat <- model.matrix(~ cluster + 0, data.frame(cluster = cluster))
  dataset <- cbind(designmat, dataset)
  # Create output list to hold results
  res <- vector(mode = "list", length = length(unique(cluster)))
  names(res) <- attributes(designmat)$dimnames[[2]]
  
  # Create model formulas
  if (!is.null(fixed_effects) && !is.null(random_effects)) {
    model_rhs <- paste0(c(paste0(fixed_effects, collapse = " + "),
                          paste0("(1|", random_effects, ")", collapse = " + ")),
                        collapse = " + ")
    if (verbose == TRUE) {
      message(paste("Using null model:", "cluster ~", model_rhs))
    }
  } else if (!is.null(fixed_effects) && is.null(random_effects)) {
    model_rhs <- paste0(fixed_effects, collapse = " + ")
    if (verbose == TRUE) {
      message(paste("Using null model:", "cluster ~", model_rhs))
      # For now, do not allow models without mixed effects terms
      stop("No random effects specified")
    }
  } else if (is.null(fixed_effects) && !is.null(random_effects)) {
    model_rhs <- paste0("(1|", random_effects, ")", collapse = " + ")
    if (verbose == TRUE) {
      message(paste("Using null model:", "cluster ~", model_rhs))
    }
  } else {
    model_rhs <- "1" # only includes intercept
    if (verbose == TRUE) {
      message(paste("Using null model:", "cluster ~", model_rhs))
      stop("No random or fixed effects specified")
    }
  }
  
  # Initialize list to store model objects for each cluster
  cluster_models <- vector(mode = "list",
                           length = length(attributes(designmat)$dimnames[[2]]))
  names(cluster_models) <- attributes(designmat)$dimnames[[2]]
  
  # Run nested mixed-effects models for each cluster
  for (i in seq_along(attributes(designmat)$dimnames[[2]])) {
    test_cluster <- attributes(designmat)$dimnames[[2]][i]
    if (verbose == TRUE) {
      message(paste("Creating logistic mixed models for", test_cluster))
    }
    null_fm <- as.formula(paste0(c(paste0(test_cluster, " ~ 1 + "),
                                   model_rhs), collapse = ""))
    full_fm <- as.formula(paste0(c(paste0(test_cluster, " ~ ", contrast, " + "),
                                   model_rhs), collapse = ""))
    # Run null and full mixed-effects models
    null_model <- lme4::glmer(formula = null_fm, data = dataset,
                              family = binomial, nAGQ = 1, verbose = 0,
                              control = lme4::glmerControl(optimizer = "bobyqa"))
    full_model <- lme4::glmer(formula = full_fm, data = dataset,
                              family = binomial, nAGQ = 1, verbose = 0,
                              control = lme4::glmerControl(optimizer = "bobyqa"))
    model_lrt <- anova(null_model, full_model)
    # calculate confidence intervals for contrast term beta
    contrast_lvl2 <- paste0(contrast, levels(dataset[[contrast]])[2])
    contrast_ci <- lme4::confint.merMod(full_model, method = "Wald",
                                        parm = contrast_lvl2)
    # Save model objects to list
    cluster_models[[i]]$null_model <- null_model
    cluster_models[[i]]$full_model <- full_model
    cluster_models[[i]]$model_lrt <- model_lrt
    cluster_models[[i]]$confint <- contrast_ci
  }
  
  # Organize results into output dataframe
  output <- data.frame(cluster = attributes(designmat)$dimnames[[2]],
                       size = colSums(designmat))
  output$model.pvalue <- sapply(cluster_models, function(x) x$model_lrt[["Pr(>Chisq)"]][2])
  output[[paste(contrast_lvl2, "OR", sep = ".")]] <- sapply(cluster_models, function(x) exp(lme4::fixef(x$full)[[contrast_lvl2]]))
  output[[paste(contrast_lvl2, "OR", "95pct.ci.lower", sep = ".")]] <- sapply(cluster_models, function(x) exp(x$confint[contrast_lvl2, "2.5 %"]))
  output[[paste(contrast_lvl2, "OR", "95pct.ci.upper", sep = ".")]] <- sapply(cluster_models, function(x) exp(x$confint[contrast_lvl2, "97.5 %"]))
  
  tb = proc.time()[3] - ta;
  cat("\n ..........  Exit MASC.\n");
  cat("             Execution time = ", tb, " s.\n", sep = "");
  
  # Return MASC results
  return(output)
}
